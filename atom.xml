<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>入坑随手记</title>
  
  <subtitle>爱的人和喜欢的工作，缺一不可</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-07-26T10:56:59.799Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>coral</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>jvm学习笔记6-HotSpot的算法细节实现</title>
    <link href="http://yoursite.com/2020/07/26/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%E5%AE%9E%E7%8E%B0/"/>
    <id>http://yoursite.com/2020/07/26/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06-HotSpot%E7%9A%84%E7%AE%97%E6%B3%95%E7%BB%86%E8%8A%82%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-07-26T10:56:00.000Z</published>
    <updated>2020-07-26T10:56:59.799Z</updated>
    
    <content type="html"><![CDATA[<p>前面学习了怎么判别要回收的对象，以及垃圾回收的一些方式、标记-清除算法、标记-复制算法、标记-整理算法。现在看看我们每天使用的HotSpot虚拟机中算法的细节实现。</p><h2 id="根节点枚举"><a href="#根节点枚举" class="headerlink" title="根节点枚举"></a>根节点枚举</h2><p>前面已经学习到可作为GC Roots的一些变量或者属性，但是实际上在查找过程中要做到高效也是很困难的，要逐个检查以这里为起源的引用肯定要消耗不少时间。</p><p>而且迄今为止，所有收集器在<strong>枚举根节点这步骤的时候都是需要暂停所有的用户线程</strong>的，这时就会面临和前面整理内存碎片算法中”Stop The World“同样的问题。</p><p>目前主流的jvm使用的都是准确式垃圾回收，所以在用户线程停顿的时候，不用一个不漏的检查所有的上下文和全局引用为止，虚拟机应该是有办法知道哪儿存放着对象引用的。在HotSpot中，是使用一组OopMap的数据结构达到这一目标的。一旦类加载完成，会在特定的为止记录下来栈里或者寄存器里哪些位置是引用。这样收集器在扫描的时候就可以直接拿到了，不用真正一个不漏的从方法区等GC Roots查找。</p><h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>在OopMap的协助下，HotSpot可以快速的完成GC Roots枚举，但是有一个问题随之而来就是引用的变化，即导致OopMap中内容变化的指令非常多，如果给每一个指令都生成一个OopMap，就会有大量的额外存储空间，空间成本会越来越大。</p><p>这时候HotSpot就很机智了，没有上面说的那么愚蠢了。HotSpot只是在一个<strong>特定位置</strong>记录这些信息，这些位置被称为<strong>安全点（SafePoint）</strong></p><p>安全点的选取方式：<strong>是否能让程序长时间执行的特征为标准</strong>，比如：方法调用、循环跳转、异常跳转等都属于长时间执行。</p><p>在实际的工作中，如果在垃圾收集发生时，所有的工作线程都跑到最近的一个安全点，然后停顿下来。2种方案：</p><h5 id="抢先式中断"><a href="#抢先式中断" class="headerlink" title="抢先式中断"></a>抢先式中断</h5><p>在垃圾收集发生时，系统首先把所有的线程全部中断，如果发现用户线程中断的地方不在安全点，就恢复这条线程，让他跑到最近的安全点。<br>现在几乎没有虚拟机采用这种方式。</p><h5 id="主动式中断"><a href="#主动式中断" class="headerlink" title="主动式中断"></a>主动式中断</h5><p>在垃圾收集发生时，不直接中断线程，而是设置一个标志位，各个线程在执行的时候不停的主动轮询这个标志位，一旦发现中断标志位为真，就在最近的安全点主动中断挂起。轮询标志的地方和安全点是重合的。<br>另外还需要加上创建对象和其他需要在java堆上分配内存的地方，这是为了检查是否即将发生的垃圾收集，避免没有足够的内存分配给新对象</p><h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>使用安全点的问题可以很好的解决如何停顿用户线程，但是只能保证程序在运行时候，在不太长的时间内遇到一个安全点。如果程序长时间处于”不运行“的时候，即程序处于”sleep”或者”blocked“的状态，这时候线程就无法响应虚拟机的中断请求，不能走到安全的地方中断自己，虚拟机也可能等待线程重新被激活分配处理器时间。对于这种情况，就需要引入<strong>安全区域</strong>解决。</p><p>安全区域是指能确保在某一块代码区域中，引用关系不会发生变化。因此，在这个区域中的任何地方开始垃圾收集都是安全的。可以看做是一个扩展的安全点。</p><p>当用户线程执行到安全区域的时候，首先会标识自己进入到了安全区域，这样虚拟机在开始垃圾收集的时候就不用考虑这些已声明自己再安全区域的线程了。当线程要离开安全区域的时候，要先检查下时候已虚拟机是否完成了根节点枚举，如果完成了，就当什么事情都没有发生过；如果没有完成，就待在安全区域，知道收到可以离开安全区域的信号为止。</p><h2 id="记忆集和卡表"><a href="#记忆集和卡表" class="headerlink" title="记忆集和卡表"></a>记忆集和卡表</h2><p>在前面介绍过的分代收集理论中，为了解决对象跨代引用带来的问题，垃圾收集器在新生代建立了一个记忆集（remrmberrd set）的数据结构，用来避免把整个老年代加紧GC Roots的扫描范围中。</p><p>记忆集本身是一种用于记录从非收集区指向收集区的指针的集合的抽象数据结构，不考虑实现成本的话，最简单的实现是用非收集区的所有含跨代引用的对象数组来实现。但是这种方式在空间占用还是维护成本上都有高昂的代价，在实际的垃圾收集过程中，收集器只需要通过记忆集判断出哪一块非收集区域是否存在指向收集区域的指针就可以了，并不需要全部了解所有的跨代指针。列举几种可选择的记忆精度</p><ul><li>字长精度：每个记录精确到一个机器字长</li><li>对象精度：每个记录精确到一个对象，该对象中有字段包含跨代指针</li><li>卡精度：每个记录精确到一块内存区域，该区域中有对象包含跨代指针</li></ul><p>其中第3种就是我们说的<strong>卡表</strong>的方式实现记忆集，也是目前最常用的方式。<strong>卡表和记忆集的关系，可以理解为java中hashmap和map的关系，卡表是记忆集的一种具体实现方式</strong></p><p>卡表最简单的实现就是一个字节数组，HotSpot中就是这么实现的。</p><p>这个字节数据中每一个元素对应一块内存区域，这块内存被称为<strong>卡页</strong>，通常一个卡页中包含很多对象，只要卡页中有一个或者多个对象存在跨代引用，就将卡表对应元素的值标记为1，称为该元素变脏，没有标识默认是0。在垃圾收集发生时，只要筛选出来标识为1的元素，就能找到哪些内存区域中包含着跨代指针，将对应的内存区域加入到GC Roots中一并扫描。</p><h2 id="写屏障"><a href="#写屏障" class="headerlink" title="写屏障"></a>写屏障</h2><p>上面提到了卡表的作用，但是卡表在实际的运行场景中，是怎么更新卡表呢？我们知道，卡表的更新（变脏）发生在引用类型赋值的那一刻。那怎么保证在对象赋值的那一刻去更新维护卡表呢？HotSpot是通过<strong>写屏障</strong>技术维护卡表状态的。</p><p>写屏障其实就是一个类似AOP切面的操作，在引用对象赋值是产生一个环形通知，供程序做额外的动作。也就是说在赋值前后都是在写屏障的覆盖范畴之内。</p><p>写屏障分为<strong>写前屏障</strong>和<strong>写后屏障</strong>，在G1收集器出来之前，其他的收集器都是采用的写后屏障。</p><p>应用写屏障后，每次引用的更新，都会有对应的开销，不过这个开销和GC扫描整个老年代的代价相比小很多。<br>除了写屏障的开销，卡表在高并发的场景下，也会有”伪共享“的问题。为了避免伪共享的问题，一种解决办法是不采用无条件的写屏障，而是先检查卡表的标记，只有当卡表该元素未被标记的时候才将其标记为变脏。</p><h2 id="并发的可达性分析"><a href="#并发的可达性分析" class="headerlink" title="并发的可达性分析"></a>并发的可达性分析</h2><p>之前有提到过的可达性分析算法的要求是：<strong>全过程基于一个能保证一致性的快照中才能够进行分析</strong></p><p><strong>标记</strong>阶段是所有追踪式垃圾收集器的共同特征。如果这个阶段会随着堆的增大而等比例的增大停顿时间，其影响会波及到几乎所有的垃圾收集器。同时如果这个阶段能削减停顿时间的话，收益也是系统性的。</p><p>想要解决或者降低用户线程的停顿时间，就需要搞清楚为什么必须在一个能保障一致性的快照上进行对象图的遍历？为了解释这个问题，我们引入<strong>三色标记法</strong>：</p><ul><li>白色：表示对象尚未被垃圾收集器访问过，在可达性分析的初始阶段的话，显然所有的对象都是白色的。在分析结束阶段的话，如果是白色的对象，表示该对象不可达。</li><li>黑色：表示对象已经被垃圾收集器访问过，且这个对象的所有引用都被扫描过，它是安全存活的，如果有其他的对象引用指向黑色对象，无需重新扫描一遍。黑色对象不可能不经过灰色对象直接指向某个白色对象。</li><li>灰色：表示对象已经被垃圾收集器访问过，但这个对象上至少还有一个引用没有被扫描过。</li></ul><p>在可达性分析的过程中，我们可以想象下，如果此时的用户线程是冻结的，只有收集器在工作，那不会有任何的问题。但如果用户线程和收集器是并发工作呢？收集器在对象图上标记颜色，同时工作线程在修改引用关系（修改对象图结构），这样会出现两种后果：一种是把原本消亡的对象标记为存活，这种可以容忍，下次回收这部分残余垃圾即可；另一种就是把存活的对象标记为已消亡，这种就致命了，程序肯定会发生错误。</p><p>如下图所示：<br><img src="https://img-blog.csdnimg.cn/20200726183711510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzYTEyMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>理论证明：只有发生以下2种条件同时满足时，才会产生”对象消失“的问题：</p><ul><li>赋值器插入一条或多条从黑色对象到白色对象的新引用；</li><li>赋值器删除了全部从灰色对象到该白色对象的直接或者间接引用。</li></ul><p>因此，要解决并发扫描时候对象消失的问题，只要破坏上面两个条件的其中一个即可。由此产生两种方案：<strong>增量更新</strong>和<strong>原始快照</strong></p><h5 id="增量更新"><a href="#增量更新" class="headerlink" title="增量更新"></a>增量更新</h5><p>增量更新就是破坏第一个条件，当黑色对象插入新的指向白色对象的引用时，就将新插入的引用记录下来，等并发扫描结束后，再将这些记录的引用关系中的黑色对象为根，重新扫描一次。也就是说：黑色对象一旦插入指向白色对象的引用之后，它就变成灰色对象了；</p><h5 id="原始快照"><a href="#原始快照" class="headerlink" title="原始快照"></a>原始快照</h5><p>原始快照就是破坏第二个条件，当灰色对象要删除指向白色对象的引用关系时，就将这个要删除的引用记录下来，在并发扫描结束后，再将这些记录的引用关系中的灰色对象为根，重新扫描一遍。也就是说：无论引用关系删除与否。都会按照刚开始扫描那一刻的的对象图快照来进行搜索。</p><p>以上无论是增量更新还是原始快照，虚拟机的操作记录都是通过写屏障实现的。<br>在HotSpot中，CMS是基于增量更新来做并发标记的；G1是用原始快照来做实现的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前面学习了怎么判别要回收的对象，以及垃圾回收的一些方式、标记-清除算法、标记-复制算法、标记-整理算法。现在看看我们每天使用的HotSpot虚拟机中算法的细节实现。&lt;/p&gt;
&lt;h2 id=&quot;根节点枚举&quot;&gt;&lt;a href=&quot;#根节点枚举&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习笔记5--垃圾回收算法</title>
    <link href="http://yoursite.com/2020/06/04/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/06/04/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/</id>
    <published>2020-06-03T16:36:00.000Z</published>
    <updated>2020-06-03T16:37:03.097Z</updated>
    
    <content type="html"><![CDATA[<p>垃圾回收算法可分为2类：<br>    * 引用计数式垃圾收集（直接垃圾收集）<br>    * 追踪式垃圾收集（间接垃圾收集）</p><p>java主流的虚拟机都是采用追踪式垃圾收集的方式，我们主要学习这个。</p><h2 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h2><ul><li>弱分代假说：绝大部分对象都是朝生夕灭的</li><li>强分代假说：熬过越多次垃圾收集过程的对象就越难消亡</li><li>跨代引用假说：相对于同代引用只占极少数</li></ul><p>第3条是根据前2条假说逻辑得出的隐含推论：存在相互引用的2个对象，是应该同时生存或者消亡的。举个例子，如果某个新生代对象存在跨代引用，由于老年代难以消亡，该引用会使得新生代对象在回收时同样存活，进而年龄增长，晋升到老年代中，这时候跨代引用就自然消除了。</p><p>依据这条假说，我们就不应再为了少量的跨代引用区扫描整个老年代，也不必浪费空间专门记录每一个对象是否存在及存在哪些跨代引用，<strong>只需要在新生代建立一个全局的数据结构（remembered set），这个结构把老年代划分成若干块，标识出老年代的哪一块会存在跨代引用。此后当发生MInor GC的时候，只有包含跨代引用的小跨内存中的对象才会被加入到GC Roots进行扫描。</strong></p><h2 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h2><p>是最基础的垃圾收集算法。首先标记需要回收的对象（也可以反过来标记存活的对象），标记完成后，统一回收所有标记（或者未被标记）的对象。</p><p><strong>标记的过程就是对象的生死判定过程</strong></p><p>回收前后的状态如图所示：</p><img src="https://img-blog.csdnimg.cn/20200603234449440.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzYTEyMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="图片替换文本" width="500" height="300" align="bottom" /><p>主要缺点：</p><ul><li>执行效率不稳定。如果堆中包含大量的对象，其中有大部分是需要被回收的，就需要大量的标记和清除动作，导致标记和清除动作的执行效率随着对象的增多而降低；</li><li>内存空间的碎片化。标记和清除之后会产生大量的不连续的内存碎片，内存碎片太多可能会导致以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发一次垃圾收集动作</li></ul><h2 id="标记-复制算法"><a href="#标记-复制算法" class="headerlink" title="标记-复制算法"></a>标记-复制算法</h2><p>为了解决标记-清除算法面对大量可回收对象时执行效率底下的问题，提出的一种“半区复制”的垃圾收集算法。</p><p>它将可用的内存容量分为大小相等的2块，每次只使用1块。当这块用完了，将还活着的对象复制到另一块内存上，然后把已使用的内存块一次清理掉。</p><p>如果内存中多数对象都是存活的，这种算法就会产生大量的对象间复制的开销，但是对于多数对象是可回收的场景，算法需要复制的就是少量存活的对象，而且每次都是针对整个半区内存进行回收，分配内存时也不用考虑内存碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。</p><p>回收前后状态如图：</p><img src="https://img-blog.csdnimg.cn/2020060323574344.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzYTEyMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="图片替换文本" width="500" height="300" align="bottom" /><p>优点：实现简单，运行高效<br>缺点：可用的内存缩小为原来的一半，空间浪费过多</p><p>现代商用的虚拟机大多优先采用这种算法去回收新生代，IBM曾经有一项专门的量化研究：<strong>新生代的有98%的对象都熬不过第一轮的收集</strong>，因此并不用按照1:1的比例划分新生代的内存空间。</p><p>HotSpot虚拟机的Serial、ParNew等新生代收集器均采用了一种更优化的半区分代复制策略——“Appel式回收”。具体做法：把新生代划分较大的一块Eden空间和两块较小的Survivor空间，每次分配内存只使用Eden和一块Survivor。发生垃圾收集时，将Eden和Survivor上仍然存活的对象一次性的复制到另外一块Survivor空间上，然后直接清理到Eden和已用过的那块Survivor空间。</p><p>HotSpot默认Eden和Survivor的大小比例是8:1，即每次新生代的可用空间占用整个新生代空间的90%</p><h2 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h2><p>标记-复制算法在对象存活率较高的时候，有大量的对象复制操作，效率将会降低。更为极端的是，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中存在100%对象存活的极端情况，所以老年代不能直接选用标记-复制算法。</p><p>针对老年代对象的特点，提出了一种有针对性的“标记-整理”算法。<br>其中标记的过程都一样，但是后续动作是让所有存活的对象向内存空间的一端移动，然后直接清理掉边界以外的内存。如图所示：</p><img src="https://img-blog.csdnimg.cn/20200604001732842.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzYTEyMQ==,size_16,color_FFFFFF,t_70#pic_center" alt="图片替换文本" width="500" height="300" align="bottom" /><p>标记-清除算法和标记-整理算法的本质差异在于前者是一种非移动式的回收算法，后者是移动式的。是否移动存活对象是一种优缺点共存的风险决策：</p><ul><li>如果移动存活对象，尤其是在老年代这种每次都有大量对象存活的区域，移动存活并更新所有对象的引用是一种极为负重的操作。这种操作需要暂停整个用户应用程序才能进行，被称为“Stop The World”</li><li>但是如果和标记-清除一样不考虑移动和整理存活对象的话，碎片化的空间只能依赖于更复杂的内存分配器和内存访问器来解决。然而内存访问是用户程序最频繁的操作，如果在这一环节增加负担，会影响整个应用程序的吞吐量。</li></ul><p>基于以上2点来看，是否移动对象都存在弊端，移动则内存回收时更复杂，不移动则内存分配时更复杂。HotSpot虚拟机里面关注吞吐量的Parallel Scavenge收集器是基于标记-整理算法的，而关注延迟的CMS收集器则是基于标记-清除算法的，这也从侧面印证这点。</p><h2 id="“和稀泥”方案"><a href="#“和稀泥”方案" class="headerlink" title="“和稀泥”方案"></a>“和稀泥”方案</h2><p>最后提一种“和稀泥”的解决方案：不在内存分配和访问上增加太大的负担，具体做法是虚拟机平时大多数时候采用标记-清除算法，暂时容忍内存碎片的存在，直到内存空间的碎片化程度已经影响到对象分配时，再采用标记-整理算法收集一次，获得规整的内存空间。</p><p>基于标记-清除算法的CMS收集器面临空间碎片过多时采用的就是这种处理办法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;垃圾回收算法可分为2类：&lt;br&gt;    * 引用计数式垃圾收集（直接垃圾收集）&lt;br&gt;    * 追踪式垃圾收集（间接垃圾收集）&lt;/p&gt;
&lt;p&gt;java主流的虚拟机都是采用追踪式垃圾收集的方式，我们主要学习这个。&lt;/p&gt;
&lt;h2 id=&quot;分代收集&quot;&gt;&lt;a href=&quot;#分代
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习笔记4--堆区和方法区的对象回收判别</title>
    <link href="http://yoursite.com/2020/06/03/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6%E5%88%A4%E5%88%AB/"/>
    <id>http://yoursite.com/2020/06/03/jvm%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04-%E5%AF%B9%E8%B1%A1%E5%92%8C%E6%96%B9%E6%B3%95%E5%8C%BA%E7%9A%84%E5%9B%9E%E6%94%B6%E5%88%A4%E5%88%AB/</id>
    <published>2020-06-02T17:02:00.000Z</published>
    <updated>2020-06-03T16:38:55.199Z</updated>
    
    <content type="html"><![CDATA[<h2 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h2><p>前面有提到jvm的内存模型，我们知道，程序计数器、虚拟机栈和本地方法栈是和线程<strong>同生共死</strong>的，每个栈帧的大小在类结构确定下来之后就都是已知的。因此这几个区域的内存分配和回收都是有确定性的。</p><p>然而，java堆和方法区却有着显著的不确定性。只有程序在运行期间，我们才知道具体要创建哪些对象，创建多少对象，分配多少内存。这部分的内存分配和回收都是动态的。所以垃圾回收器所关心的就是这部分内存的管理。</p><p>复习完之前的内容，我们就知道了垃圾回收器的关心重点在于<strong>堆内存的对象管理</strong>和<strong>方法区管理</strong>。</p><p>在垃圾回收器回收内存之前，要做的第一件事，就是判别哪些对象实例需要被回收？换句话说，就是要判断哪些对象”存活“，哪些对象已经“死去”。</p><p>死去就是说对象不可能被任何途径所使用</p><hr><h2 id="对象的生死判别"><a href="#对象的生死判别" class="headerlink" title="对象的生死判别"></a>对象的生死判别</h2><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>引用计数法是一种常见的判别对象是否存活的方式，使用的方式是给每一个对象添加一个引用计数器。</p><p>当有一个地方引用它时，计数器加1；当引用失效时，计数器减1。<br>任何时候引用计数器为0就表示这个对象不能再被使用。</p><p>优点：原理简单，判定效率高<br>缺点：需要大量额外的处理才能保证正确的工作，如对象之间循环相互引用<br>语言：Python、微软的COM等在使用该方式。<strong>jvm没有使用该方式</strong>。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>当前主流的语言大多采用该方法来判断对象的“生死”。</p><p>基本思路：通过一系列被称为“GC Roots”的根对象作为起始节点集，从这些节点开始，根据引用关系向下搜索，搜索过程中走过的路被称为“引用链”，如果某个对象到“GC Roots”没有任何的引用链相连，或者说从根节点到该对象不可达时，说明该对象是不可能再被使用的。如图所示：</p><img src="https://img-blog.csdnimg.cn/20200603000129927.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzYTEyMQ==" alt="图片替换文本" width="500" height="300" align="bottom" /><p>图中object5、object6、object7虽然相互有关联，但是他们到“GC Roots”是不可达的，所以会被判定为可回收的对象。</p><p>再java技术体系中，固定可作为“GC Roots”的对象包括以下几种：</p><ul><li>java虚拟机栈中本地变量表中引用的对象，比如各个线程中被调用的方法堆栈中使用到的参数、局部变量和临时变量等；</li><li>在方法区中类静态属性引用的对象；</li><li>方法区中常量引用的对象；</li><li>本地方法栈中JNI（native方法）引用的对象；</li><li>虚拟机内部的引用，如基础数据类型对应的class对象，一些常驻的异常对象，还有系统类加载器等；</li><li>所有被同步所只有的对象；</li><li>反应java虚拟机内部情况的JMXBean、JVMNI中注册的回调、本地代码缓存等；</li></ul><p>除了以上的这些，不同的垃圾回收器根据回收的区域不同，会临时加一些对象进去，共同构成完整的“GC Roots”集合</p><hr><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>无论是通过引用计数法，还是判断对象的引用链可达，都要根据“引用”来判断，所以都和“引用”脱离不了关系。</p><p>比如有这样一个场景，我们希望在内存足够的时候，对象可以保留在内存中；当在进行垃圾回收之后内存依然紧张时，就可以抛弃这些对象——很多的系统缓存功能否符合这样的场景。</p><p>根据场景，我们将引用分为：<strong>强引用、软引用、弱引用、虚引用</strong>四类，这4中类型的引用强度依次减弱。</p><h4 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h4><p>即类似于  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure><p>只要强引用关系还存在，垃圾回收器永远不会回收掉被引用的对象。</p><h4 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h4><p>用来描述一些还有用，但非必须的对象。只要被软引用关联的对象，在系统将要发生内存溢出异常之前，会把这些对象列为回收范围进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常。</p><h4 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h4><p>也是用来描述非必须的对象，强度比软引用更弱一些，被弱引用关联的对象，只能存活到下一次垃圾回收发生为止。当垃圾回收器开始工作的时候，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</p><h4 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h4><p>是最弱的一种引用关系，一个对象是否有虚引用存在，完全不会影响其生存时间，也无法通过虚引用获取一个对象实例。为一个对象设立虚引用关联的唯一目的就是在这个对象被回收时会收到一个<strong>系统通知</strong></p><hr><h2 id="回收方法区"><a href="#回收方法区" class="headerlink" title="回收方法区"></a>回收方法区</h2><p>虽然在java堆中的一次回收可以回收70%-99%的内存空间，方法区的回收成果远低于此，但是在一些虚拟机中也会有方法区的回收设计。</p><p>方法区的垃圾收集主要回收2部分内容：废弃的常量和不再使用的类型。回收废弃常量的方式和java堆中的回收方式类似。</p><p>比如常量池中的一个字符串“java”，当前系统中没有一个字符串对象的值是“java”，换句话说，已经没有任何字符串对象引用常量池中的“java”常量，且虚拟机中也没有其他地方引用这个常量。这时候如果发生垃圾回收，该常量就会被清理出常量池。常量池中的其他类型、接口、方法、字段的符号引用都是类似。</p><p>判断一个常量是否废弃比较简单，但是判断一个类型是否属于“不再被使用的类”条件就比较苛刻了。需要同时满足3个条件：</p><ul><li>该类的所有实例都已经被回收，也就是说jav堆中不存在该类及任何派生类的实例</li><li>加载该类的类加载器已经被回收</li><li>该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>java虚拟机允许对满足以上3个条件的无用类进行回收，但是<strong>并不是和对象一样，没有引用了就必然回收</strong>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;复习&quot;&gt;&lt;a href=&quot;#复习&quot; class=&quot;headerlink&quot; title=&quot;复习&quot;&gt;&lt;/a&gt;复习&lt;/h2&gt;&lt;p&gt;前面有提到jvm的内存模型，我们知道，程序计数器、虚拟机栈和本地方法栈是和线程&lt;strong&gt;同生共死&lt;/strong&gt;的，每个栈帧的大小在
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习笔记3--对象的内存布局</title>
    <link href="http://yoursite.com/2020/05/20/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/"/>
    <id>http://yoursite.com/2020/05/20/%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%86%85%E5%AD%98%E5%B8%83%E5%B1%80/</id>
    <published>2020-05-20T15:54:00.000Z</published>
    <updated>2020-06-02T17:02:33.339Z</updated>
    
    <content type="html"><![CDATA[<p>今天是520，不管有没有对象，都要学习呀</p><p>在我们经常使用的HotSpot虚拟机中，对象在堆内存中的布局可以分为3个部分：</p><ul><li>对象头</li><li>实例数据</li><li>对齐填充</li></ul><h2 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h2><p>对象的对象头包含2类信息：</p><h5 id="用于存储对象自身的运行时数据"><a href="#用于存储对象自身的运行时数据" class="headerlink" title="用于存储对象自身的运行时数据"></a>用于存储对象自身的运行时数据</h5><p>如哈希码、GC分代年龄、锁状态标志、线程持有的锁、偏向线程的id、偏向时间戳等。这些数据的长度在32位和64位虚拟机中，分别占用32bit和64bit，官方称之为”<strong>Mark Word</strong>“</p><p>mark word如图所示：<br><img src="https://img-blog.csdnimg.cn/20200520233412749.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzYTEyMQ==,size_16,color_FFFFFF,t_70" alt="图片替换文本" width="400" height="100" align="bottom" /></p><h5 id="类型指针"><a href="#类型指针" class="headerlink" title="类型指针"></a>类型指针</h5><p>即对象指向它的类型元数据的指针，jvm通过这个指针确认该对象是哪个类的实例</p><h2 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h2><p>对象真正存储的有效信息，即我们在程序代码中定义的各种字段内容，无论是从父类集成来的，还是子类自有的都必须记录下来。</p><p>存储的顺序受<strong>jvm的分配策略参数</strong>和<strong>字段在java源码中的定义顺序</strong>的影响<br>HotSpot默认的分配顺序是longs/doubles、ints、shorts/chars、bytes/booleans、opps，可以看到相同宽度的字段会被分配到一起存放，在满足这个条件的前提下，<strong>父类的字段放在子类的前面</strong></p><h2 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h2><p>这部分不是必然的，也没有特殊的含义，仅仅是占位的作用。<br>由于HotSpot jvm的内存管理系统要求对象的起始位置必须是8字节的倍数，也就是说<strong>任何对象的大小都必须是8字节的倍数</strong>。</p><p>从上面可以看到，对象的头部已经是8字节的倍数了，所以如果对象实例没有对齐的，就要通过对齐填充了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天是520，不管有没有对象，都要学习呀&lt;/p&gt;
&lt;p&gt;在我们经常使用的HotSpot虚拟机中，对象在堆内存中的布局可以分为3个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对象头&lt;/li&gt;
&lt;li&gt;实例数据&lt;/li&gt;
&lt;li&gt;对齐填充&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;对象头&quot;&gt;
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习笔记2--对象的产生</title>
    <link href="http://yoursite.com/2020/05/15/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%A7%E7%94%9F/"/>
    <id>http://yoursite.com/2020/05/15/java%E5%AF%B9%E8%B1%A1%E7%9A%84%E4%BA%A7%E7%94%9F/</id>
    <published>2020-05-14T16:25:00.000Z</published>
    <updated>2020-06-02T17:02:09.905Z</updated>
    
    <content type="html"><![CDATA[<h2 id="提出问题"><a href="#提出问题" class="headerlink" title="提出问题"></a>提出问题</h2><p>在java的世界中，我们频繁的会使用对象。创建一个对象对我们而言，就是一行代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User user &#x3D; new User(&quot;hello world&quot;);</span><br></pre></td></tr></table></figure><p>在这行代码的背后，jvm都做了哪些工作呢？学习总结下。</p><h2 id="对象创建过程"><a href="#对象创建过程" class="headerlink" title="对象创建过程"></a>对象创建过程</h2><p>当jvm在执行字节码指令的时候，遇到一条字节码new指令的时候，做以如图所示的以下工作：<br><img src="https://img-blog.csdnimg.cn/20200515002143342.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzYTEyMQ==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><h3 id="检查常量池"><a href="#检查常量池" class="headerlink" title="检查常量池"></a>检查常量池</h3><p>先去检查下这个指定的参数在常量池中是否可以定位到一个类的符号引用，并且要去检查这个符号引用所代表的类是否已经被加载、解析和初始化过。有的话，就直接引用；没有的话就要执行下一步。</p><h3 id="执行类加载"><a href="#执行类加载" class="headerlink" title="执行类加载"></a>执行类加载</h3><p>类加载过程细节后面填坑，这块比较复杂。</p><h3 id="给对象分配内存"><a href="#给对象分配内存" class="headerlink" title="给对象分配内存"></a>给对象分配内存</h3><p>类加载检查之后，虚拟机要给新生成的对象分配内存。<strong>对象所需内存大小在类加载完成后就完全确定了</strong>  如何确定的后面再填坑。</p><p>给对象分配内存，就是在java堆中把一块确定大小的内存区域划分出来。分配的方式有2种：</p><ul><li><strong>指针碰撞</strong>：假设java堆中的内存都是绝对规整的，所有使用过的或者被分配的在一遍，空闲内存放在另一边，中间放一个指针作为分界点。那本次的内存分配就是把指针从当前位置向空闲的方向移动一段与对象大小相等的距离，这种方式叫做指针碰撞</li><li><strong>空闲列表</strong>：如果java堆不是规整的，已被使用的内存和未被分配的空闲内存相互交错放在一起，那就没有办法使用指针碰撞的方式了，就需要维护一个列表，记录哪些内存区域是可用的。在分配的时候从可用的区域中找到一块足够大的划分给当前对象实例，并更新列表记录，这种方式叫做空闲列表</li></ul><p>在划分可用空间给对象的时候，需要考虑一个问题：创建对象、给对象分配内存在虚拟机中是非常高频的行为，仅仅修改指针的位置，在并发情况下也不是线程安全的操作，可能出现在给A对象分配的内存，指针还没有修改，B对象也在基于原来的指针分配内存的情况。解决这种问题就有2种方案：</p><ul><li>采用CAS+失败重试来保证更新操作的原子性</li><li>将内存分配的动作按照线程划分到不同的空间中进行，即每个线程提前先分配到一小块内存，称为<strong>本地线程分配缓冲</strong>（TLAB），哪个线程要分配内存，就在自己的分配缓冲中进行，本地缓冲用完了再采用方案1同步锁定分配</li></ul><h3 id="初始化分配的内存空间"><a href="#初始化分配的内存空间" class="headerlink" title="初始化分配的内存空间"></a>初始化分配的内存空间</h3><p>jvm将分配到的内存空间都初始化成零值，如果采用了TLAB的方案，这一步可以提前至TLAB分配时进行。这步操作<strong>保证对象的实例字段在java代码中可以不赋初始值就能直接使用</strong>。</p><h3 id="设置对象"><a href="#设置对象" class="headerlink" title="设置对象"></a>设置对象</h3><p>jvm需要对对象进行必要的设置，比如对象是哪个类的实例、如何找到类的元信息、对象的哈希码、对象的GC分代年龄等。这些信息都存放在对象的对象头中。具体的设置后面详细介绍</p><h3 id="对象构造"><a href="#对象构造" class="headerlink" title="对象构造"></a>对象构造</h3><p>上面的所有流程完成之后，一个新的对象就产生了。接下来，就要开始对这个新的对象<strong>进行构造</strong>了。只有按照业务场景给对象初始化，一个真正的对象才算是构造完成。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>一行代码，jvm就帮我们做了这么多事情。<br>还有很多的细节没有一一描述，后面每个步骤深挖的时候再完善。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;提出问题&quot;&gt;&lt;a href=&quot;#提出问题&quot; class=&quot;headerlink&quot; title=&quot;提出问题&quot;&gt;&lt;/a&gt;提出问题&lt;/h2&gt;&lt;p&gt;在java的世界中，我们频繁的会使用对象。创建一个对象对我们而言，就是一行代码：&lt;/p&gt;
&lt;figure class=&quot;hi
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>jvm学习笔记1--内存模型</title>
    <link href="http://yoursite.com/2020/05/13/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
    <id>http://yoursite.com/2020/05/13/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%A6%82%E8%BF%B0/</id>
    <published>2020-05-13T15:53:00.000Z</published>
    <updated>2020-06-02T17:01:42.424Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总体结构"><a href="#总体结构" class="headerlink" title="总体结构"></a>总体结构</h2><p>Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的时间，有的区域随着虚拟机进程的启动而一直存在，有些区域则是依赖用户线程的启动和结束而建立和销毁。如下图所示：</p><img src="https://img-blog.csdnimg.cn/20200512233118835.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NzYTEyMQ==,size_5,color_FFFFFF,t_70#pic_center" alt="图片替换文本" width="400" height="300" align="bottom" /><hr><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器占用整个数据区较小的一块空间，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的模型中，程序计数器的作用就是字节码解释器通过改变计数器的值来选取下一条要执行的指令。在代码层面上，<strong>我们经常用到的分支（if…else…）、循环、跳转、异常处理、线程恢复等基础功能都依赖这个计数器完成</strong>。</p><p>在java虚拟机中的多线程是通过线程轮流切换，分配处理器的执行时间来实现的。在任何一个确定的时刻，对于一个处理器（多核的机器就是其中的一个核），都只会执行一个线程中的一个指令，当该线程的cpu时间片用完需要让出计算资源时候，需要保存该线程当前执行位置，以便下次能够从正确的位置恢复执行，因此每个线程都有独立的程序计数器，且相互独立存储，互不影响。所以程序计数器是<strong>每个线程的私有区域</strong>。</p><p>如果线程执行的是一个java方法，计数器记录的是程序正在执行的字节码指令所在的位置，如果执行的是一个native方法，计数器的值是空值</p><hr><h2 id="java虚拟机栈（jvm-stack）"><a href="#java虚拟机栈（jvm-stack）" class="headerlink" title="java虚拟机栈（jvm stack）"></a>java虚拟机栈（jvm stack）</h2><p>jvm stack也是<strong>线程私有</strong>的，生命周期和线程一样，用来描述java方法执行时候的线程内存模型。</p><p>每个方法在执行的时候都会同步创建一个栈帧（stack frame）用来存储方法内部的局部变量表、操作数栈、动态链接、方法出口等信息。每个方法被调用知道执行完毕的过程，就是一个栈帧在jvm stack 入栈到出栈的过程</p><hr><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈和jvm stack的作用类似。区别在于，jvm stack为虚拟机执行java方法（字节码）服务，本地方法栈则是为虚拟机执行本地方法服务，也是<strong>线程私有</strong>的</p><hr><h2 id="java-堆（GC-Heap）"><a href="#java-堆（GC-Heap）" class="headerlink" title="java 堆（GC Heap）"></a>java 堆（GC Heap）</h2><p>从java应用程序的角度来说，jav堆是java应用程序所管理的最大的一块内存，<strong>被所有的线程共享</strong> ，在虚拟机启动时创建。java堆的<strong>唯一</strong>作用就是<strong>存放对象实例</strong>，java的世界里，几乎所有的对象实例都在这里分配内存。</p><p><strong>java堆是垃圾回收器管理的一块区域</strong>。</p><p>从垃圾回收的角度看，现代的垃圾回收器都是采用的分代回收理论设计的，就是我们熟悉的<strong>新生代、老年代、永久代、Eden空间、From Survivor空间、To Survivor空间等</strong>名词。在G1回收器出现为界限，之前的回收器，尤其是业界绝对主流的HotSpot虚拟机，都是采用这种经典分代的设计思想；但是到了如今，垃圾回收技术已不可同日而语，HotSpot中也出现了不采用分代设计的垃圾回收器，所以不能再按照上面的经典分代方式看待了。</p><p>从内存分配的角度看，所有线程共享的java堆可以划分出多个线程私有的分配缓冲区，有利于提升对象分配时的效率。但是无论什么角度，何种划分，都不能改变java堆存储内容的特点：<strong>存储的都是对象的实例</strong></p><hr><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区和java堆一样，是<strong>线程共享</strong>的内存区域，用于存储被虚拟机加载的<strong>类型信息、常量、静态变量、及时编译器编译后的代码缓存</strong>等。方法区还有一个别名叫做<strong>非堆</strong>，目的就是要和java堆做区分。</p><hr><h2 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h2><p>运行时常量池属于方法区的一部分，class文件中除了类的版本、字段、方法、接口等描述信息之外，还有一项信息是<strong>常量池表</strong>，用来<strong>存放编译期间生成的各种字面量和符号引用</strong>，这部分内容将在类加载后存放在方法区的运行时常量池。</p><p>运行时常量池具有动态性，即不仅仅可以存放编译期产生的常量，在运行期间的常量也可以放入池中。这种特性在代码被利用的较多的就是String类的intern()方法</p><hr><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>线程共享的内存区域：java堆、方法区（包含运行时常量池）</li><li>线程私有的内存区域：程序计数器、jvm stack、本地方法栈</li></ul><p>具体每个模块的具体功能和原理，后面分模块详细学习之后再做总结</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;总体结构&quot;&gt;&lt;a href=&quot;#总体结构&quot; class=&quot;headerlink&quot; title=&quot;总体结构&quot;&gt;&lt;/a&gt;总体结构&lt;/h2&gt;&lt;p&gt;Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域有各自的用途，以及创建和销毁的
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>Kafka的可靠性</title>
    <link href="http://yoursite.com/2020/05/11/Kafka%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/"/>
    <id>http://yoursite.com/2020/05/11/Kafka%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7/</id>
    <published>2020-05-11T15:49:00.000Z</published>
    <updated>2020-05-11T15:51:14.142Z</updated>
    
    <content type="html"><![CDATA[<p><strong>在使用kafka的时候，我们都知道kafka有很强的可靠性，或者说kafka可以保证消息不丢失。<br>那它是怎么来保证的呢？<br>或者返过来思考，在使用kafka的时候什么情况下会丢失消息呢？</strong></p><p>从应用kafka的三个角度来理解kafka的可靠性保证</p><h3 id="生产者的可靠性"><a href="#生产者的可靠性" class="headerlink" title="生产者的可靠性"></a>生产者的可靠性</h3><p>在kafka的producer配置时，我们需要配置一些必要的参数来保证生产端的可靠性</p><h4 id="确认机制（request-required-acks）"><a href="#确认机制（request-required-acks）" class="headerlink" title="确认机制（request.required.acks）"></a>确认机制（request.required.acks）</h4><p>request.required.acks（下面简写ack），这个参数有三个值，分别是1, 0, -1</p><ul><li>1：producer在ISR（先不管是什么，下面有说明）中的leader已成功收到的数据并得到确认后发送下一条message。如果leader宕机了，且producer没有重试机制，则会丢失数据。</li><li>0：producer无需等待来自broker的确认而继续发送下一批消息。这种情况下数据传输效率最高，但是数据可靠性确是最低的。</li><li>-1：producer需要等待ISR中的所有follower都确认接收到数据后才算一次发送完成，可靠性最高，但是传输速率有一定的影响。但是这样也不能保证数据不丢失，比如当ISR中只有leader时，这种场景就变成了acks=1的情况</li></ul><h4 id="发送模式-（producer-type）"><a href="#发送模式-（producer-type）" class="headerlink" title="发送模式 （producer.type）"></a>发送模式 （producer.type）</h4><p>producer.type 这个参数指定了在后台线程中消息的发送方式是同步的还是异步的，如果需要确保消息的可靠性，必须要将producer.type设置为sync。</p><ul><li>producer.type=sync（默认）。默认是同步方式，所以一般不用配置</li><li>producer.type=async，设置异步模式，在producer的内存中数据缓存一定数量时以batch的形式push数据到kafka上，这样会极大的提高broker的性能，但是这样会增加丢失数据的风险。</li></ul><p>所以生产端要根据实际的业务场景，斟酌可靠性和传输性能，配置合适的参数。</p><h3 id="kafka-broker的可靠性"><a href="#kafka-broker的可靠性" class="headerlink" title="kafka broker的可靠性"></a>kafka broker的可靠性</h3><p>kafka server的可靠性保证主要是其健壮的副本策略。调整和副本相关的参数，可以保证kafka的副本策略保证生产环境的数据可靠性要求。从最原始的物理层开始解析</p><h4 id="文件存储机制"><a href="#文件存储机制" class="headerlink" title="文件存储机制"></a>文件存储机制</h4><p>kafka中每一类型的消息，我们称之为topic，生产者通过topic向kafka broker发送消息，消费者通过topic从kafka broker中读取消息。</p><p>topic在物理层由partition组成，每一个topic可以分成若干个partition。再往下，一个partition在物理层由若干个segment组成。<br>我们一一介绍 topic、partition和segment。在物理层的存储，可以在kafka的部署节点中有一个data目录，可以看到每个topic对应的partition，进入partition之后可以看到具体的segment结构。也可以通过命令来查看分区信息：<code>sh kafka-topics.sh --zookeeper localhost:2181/kafka --topic topicName --describe</code><br>无论是通过命令还是直接在目录下查看，可以看到每个partition的命名都是通过<strong>topic+有序序号</strong>命名的，最大的序号是partition数-1。partition是实际物理上的概念，而topic是逻辑上的概念。</p><p>partition再细分的segment就是数据的最小存储单位。每个partition相当于一个巨型文件被平均分配到多个大小相等的segment数据文件中（每个segment 文件中消息数量不一定相等）这种特性也方便old segment的删除，即方便已被消费的消息的清理，提高磁盘的利用率。每个partition只需要支持顺序读写就行，segment的文件生命周期由服务端配置参数决定（详细的参数配置参考官网）。</p><p>在kafka数据存储目录下，可以看到每个partition(/data/topic-01)下的数据存储细节，每一个segment文件都是由两部分组成的，<em>.index文件和</em>.log文件，分别对应segment的索引文件和数据文件，文件的命名规则是：partition全局的第一个segment从0开始，后续每个segment文件名为上一个segment文件最后一条消息的offset值，数值大小为64位，20位数字字符长度，没有数字用0填充，如下图所示：<br> <strong><em>我是图</em></strong><br>partition中如何通过offset查找message，我们暂不详细说明，后面专门写文件介绍这块</p><p>参考：</p><ul><li><a href="https://www.cnblogs.com/huxi2b/tag/Kafka/" target="_blank" rel="noopener">https://www.cnblogs.com/huxi2b/tag/Kafka/</a></li><li><a href="http://www.importnew.com/25247.html" target="_blank" rel="noopener">http://www.importnew.com/25247.html</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;在使用kafka的时候，我们都知道kafka有很强的可靠性，或者说kafka可以保证消息不丢失。&lt;br&gt;那它是怎么来保证的呢？&lt;br&gt;或者返过来思考，在使用kafka的时候什么情况下会丢失消息呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;从应用kafka的三个角度来
      
    
    </summary>
    
    
      <category term="kafka" scheme="http://yoursite.com/categories/kafka/"/>
    
    
      <category term="kafka" scheme="http://yoursite.com/tags/kafka/"/>
    
  </entry>
  
  <entry>
    <title>scrapy写爬虫注意事项</title>
    <link href="http://yoursite.com/2020/05/11/scrapy%E5%86%99%E7%88%AC%E8%99%AB%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://yoursite.com/2020/05/11/scrapy%E5%86%99%E7%88%AC%E8%99%AB%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/</id>
    <published>2020-05-11T15:47:00.000Z</published>
    <updated>2020-05-11T15:49:06.900Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前段时间有个爬虫的需求，爬的什么网站的数据就不说了，简单介绍下在学习scrapy这中间踩的坑吧。"><a href="#前段时间有个爬虫的需求，爬的什么网站的数据就不说了，简单介绍下在学习scrapy这中间踩的坑吧。" class="headerlink" title="前段时间有个爬虫的需求，爬的什么网站的数据就不说了，简单介绍下在学习scrapy这中间踩的坑吧。"></a>前段时间有个爬虫的需求，爬的什么网站的数据就不说了，简单介绍下在学习scrapy这中间踩的坑吧。</h4><blockquote><p>1、在爬取数据的时候，一定要想办法将爬虫伪装成一个浏览器，可以通过设置cookie和请求头的信息。这个具体的方法很多，随便百度一个关键词“scrapy设置请求头”，就可以出来一大堆答案。裸奔的话频率小点没啥事，但是访问频率比较高的话就会被302掉。甚至会被短时间内封掉ip，建议设置一个请求头比较保险。</p></blockquote><blockquote><p>2、使用scrapy时，要学会使用meta来传参。</p></blockquote><blockquote><p>3、要深入理解yield的用法。</p></blockquote><blockquote><p>4、item的使用尽量将需要的字段给他，不要给无关紧要的字段。</p></blockquote><blockquote><p>5、碰到异步请求的页面是，耐心找找异步请求的链接获取格式。一般来讲，请求<br>的链接都是固定的，只是某一个相关的参数不同。拼接请求就可以了。</p></blockquote><blockquote><p>6、碰到js渲染的页面时，需要使用phantomjs来加载js渲染后页面，phantomjs更像一个隐藏的浏览器，能获取到最全面的页面信息，使用时需要自己写一个js加载文件。网上很多。最便捷的就是通过标准输出将页面返回给主逻辑。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前段时间有个爬虫的需求，爬的什么网站的数据就不说了，简单介绍下在学习scrapy这中间踩的坑吧。&quot;&gt;&lt;a href=&quot;#前段时间有个爬虫的需求，爬的什么网站的数据就不说了，简单介绍下在学习scrapy这中间踩的坑吧。&quot; class=&quot;headerlink&quot; tit
      
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
      <category term="爬虫" scheme="http://yoursite.com/categories/python/%E7%88%AC%E8%99%AB/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="scrapy" scheme="http://yoursite.com/tags/scrapy/"/>
    
  </entry>
  
  <entry>
    <title>python数据清洗流程和注意点</title>
    <link href="http://yoursite.com/2020/05/11/python%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E6%B5%81%E7%A8%8B%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
    <id>http://yoursite.com/2020/05/11/python%E6%95%B0%E6%8D%AE%E6%B8%85%E6%B4%97%E6%B5%81%E7%A8%8B%E5%92%8C%E6%B3%A8%E6%84%8F%E7%82%B9/</id>
    <published>2020-05-11T15:46:00.000Z</published>
    <updated>2020-05-11T15:47:27.052Z</updated>
    
    <content type="html"><![CDATA[<h4 id="最近一直在做数据清洗业务。终于告一段落，简单的总结记录一下最近工作。方便后续查看吧。"><a href="#最近一直在做数据清洗业务。终于告一段落，简单的总结记录一下最近工作。方便后续查看吧。" class="headerlink" title="最近一直在做数据清洗业务。终于告一段落，简单的总结记录一下最近工作。方便后续查看吧。"></a>最近一直在做数据清洗业务。终于告一段落，简单的总结记录一下最近工作。方便后续查看吧。</h4><p>具体的工作流程就是将数据从hive或者原始日志中清洗、整理后入库。然后供业务方使用和展示。</p><blockquote><h3 id="开发前："><a href="#开发前：" class="headerlink" title="开发前："></a>开发前：</h3></blockquote><p>当你接到一个需求时，先考虑3点：</p><ul><li>1、你是否理解每一个字段的含义和每一个字段的存放位置（在原始日志中or现有的表中）。一定要先了解清楚每一个字段，这关乎你后续工作是否可以顺利进行。特别是有些数据是已有的，不需要重复开发清洗。多了解一些有利于后续的工作。</li></ul><ul><li><p>2、在理清楚1中的关系之后，将需求中的字段按照需求设计表或者接口。一定要在开发之前先设计好接口或者要写入的表结构。这一点非常重要，不要着急的写程序！不要着急的写程序！！不要着急的写程序！！！当你这一步完成的时候，你已经完成了30%的工作量。</p><p>  <code>根据以往经验来看，每一个需求都会有各种筛选条件（如性别、身份类型等）和要呈现的数据。所以我们可以将需求字段分为两部分：筛选字段和展示字段。筛选字段的各种条件状态一定要考虑充分，不要有遗漏或者重复包含。</code></p></li></ul><ul><li>3、了解需求中的数据的更新状态。一般来讲有一次性需求、小时级更新、天级更新和月级别更新几种更新周期。根据不同的更新周期设计不同的调用方式。不能只考虑未来的脚本执行，还需要考虑历史数据回溯等情况。设计一种方便、灵活、简单调度方法，有利于未来数据维护的便捷。</li></ul><h3 id="开发中："><a href="#开发中：" class="headerlink" title="开发中："></a>开发中：</h3><p>在上面的三点的充分考虑之后，开发脚本基本就是顺水推舟了。在设计表结构的时候，你就已经考虑到了脚本中应该怎么实现需求中的筛选字段和展示字段，所以在后续的开发过程中基本上逻辑方向不会有任何问题。但是在技术实现层面上，需要注意几个常见小细节吧。</p><ul><li>1、在python内部实现好的几种数据结构中，最常用到的应该是dict、list和set（dict和list的杂交产物）三种了。要搞清楚这三种数据结构的特性，才能在相适应的场景中发挥其作用。举个栗子：当仅需要判断集合中是否包含某一值时，可以用set实现集合，不适宜用list。因为set的时间复杂度是O(1)，更快的能得到结果，list就会比较慢，数据量很大的时候list超级慢，因为它是在遍历整个集合。建议先熟悉这三种基础的数据结构的用法和区别。</li></ul><ul><li>2、在清洗脚本过程中可能会遇到字符集编码错误的问题。一般解决的办法是，先打印出来当前的字符集编码类型，当你想要将某一类型转成utf8时，先转成unicode，再转成utf8。unicode是python字符集编码的中转站。这个google一下就有很多的解决办法。</li></ul><pre><code>强调一点就是在遇到中文乱码的问题时，先将字符串用unicode()函数转一次就好了，亲尝有效。</code></pre><ul><li>3、当我们需要入库的数据量较大时（2k条以上吧）直接insert会比较慢，而且频繁入库会影响数据同步，建议先将数据写入到本地，然后load到数据库中。速度非常快！！</li></ul><blockquote><p>三、开发后：</p></blockquote><ul><li><p>开发完成后是调试和验证数据准确性的阶段。调试不用多说，根据报错信息自行google就可以。</p></li><li><p>行百里者半九十，数据校验部分很重要。结合业务场景和上游数据来校验当前数据是最基本的方法，比如校验数据的总量、各条件下的数据量、随机抽查部分数据的正确性等都是校验数据的方式。</p></li><li><p>校验数据一定要胆大心细：误差较大就要大胆推理哪儿有问题，不一定是你的脚本有问题，也有可能是上游数据就有问题了；最基础的字段也需要仔细验证，不要因为是基础通用字段就认为一定没有问题。</p></li></ul><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>整个过程回想起来没有那么多的技术含量，但是前期的需求分析设计，中期的开发调试和后期的数据校验全是一个人的工作，所以需要你细心+耐心。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;最近一直在做数据清洗业务。终于告一段落，简单的总结记录一下最近工作。方便后续查看吧。&quot;&gt;&lt;a href=&quot;#最近一直在做数据清洗业务。终于告一段落，简单的总结记录一下最近工作。方便后续查看吧。&quot; class=&quot;headerlink&quot; title=&quot;最近一直在做数据
      
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="etl" scheme="http://yoursite.com/tags/etl/"/>
    
  </entry>
  
  <entry>
    <title>flume1.8在线上业务中的使用和总结</title>
    <link href="http://yoursite.com/2020/05/11/flume1-8%E5%9C%A8%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2020/05/11/flume1-8%E5%9C%A8%E7%BA%BF%E4%B8%8A%E4%B8%9A%E5%8A%A1%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8%E5%92%8C%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-11T15:43:00.000Z</published>
    <updated>2020-05-11T15:45:39.715Z</updated>
    
    <content type="html"><![CDATA[<h4 id="什么是flume？"><a href="#什么是flume？" class="headerlink" title="什么是flume？"></a>什么是flume？</h4><ul><li><p>flume是一个日志采集、聚合和传输的系统</p><p><img src="http://upload-images.jianshu.io/upload_images/1462670-323b82d3b5790407.jpg?imageMogr2/auto-orient/strip" alt="这里写图片描述"></p></li></ul><h4 id="作用是什么？"><a href="#作用是什么？" class="headerlink" title="作用是什么？"></a>作用是什么？</h4><ul><li>作用就是将业务集群上各个机器上的日志收集起来，对数据做集中处理。</li></ul><h4 id="部署文档"><a href="#部署文档" class="headerlink" title="部署文档"></a>部署文档</h4><ul><li>最新版的flume1.8，请参官网 <a href="http://flume.apache.org/FlumeUserGuide.html" target="_blank" rel="noopener">http://flume.apache.org/FlumeUserGuide.html</a> 的使用说明，真的很详细。</li><li>网上也有flume1.7的搭建教程，Google一下就可以，搭建过程没有太大的区别。</li></ul><h4 id="前期调研"><a href="#前期调研" class="headerlink" title="前期调研"></a>前期调研</h4><p>在考虑日志的收集之前，我们主要调研了flume和logstash两款产品。当前业界使用较多的是logstash作为日志收集的工具。现将flume和logstash在我们的业务考虑范围内的区别简单罗列：</p><ul><li>Logstash偏重于字段的预处理；flume偏重数据的传输。</li><li>Logstash有插件可以使用，配置比较灵活；flume则是强调用户的自定义开发(输入、存储、输出等)。</li><li>Logstash的输入、过滤和输出之间都有缓冲区；flume是有channel作持久化（可以自定义配置）</li></ul><h4 id="选择使用flume的原因："><a href="#选择使用flume的原因：" class="headerlink" title="选择使用flume的原因："></a>选择使用flume的原因：</h4><ul><li>传输数据的可靠性（主要因素）。每一个source和sink都被封装成一个事务存储在channel中，可以保证数据准确的被下游消费。如果下游服务挂掉，flume可以将数据持久化到本地，等待下游服务恢复后在输出。</li><li>只传输数据不解析。不会对原始的数据进行过滤和预解析，尽量保证主站机器的资源不被日志服务占据太多。所有的解析操作可以放在下游进行。</li><li>多种配置方式。有丰富的数据读取方式，tail、socket、exec等等。数据存储可以在本地或者内存，可以配置各种存储空间大小。多种数据输出方式，输出到hdfs、下游flume、es、kafka等等。</li><li>多输入输出。可以同时有多个数据源，也可以同时将数据输出到多个下游。</li><li>如果实时性要求不高的话可以采取批量读取的方式。</li><li>输出数据时可以对数据进行压缩后输出，存储带hdfs的话可能会需要吧。</li><li>有java的api，我们可以自己实现对数据的过滤。</li></ul><p>以上的调研并不能全面的概括flume的特性，只是它开箱即用的基本特性，其可扩展性很强大。</p><h4 id="我们的日志收集系统的整体框架设计"><a href="#我们的日志收集系统的整体框架设计" class="headerlink" title="我们的日志收集系统的整体框架设计"></a>我们的日志收集系统的整体框架设计</h4><p><img src="http://img.blog.csdn.net/20180227212550956?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NhMTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="日志收集框架图"></p><p>如上图所示，在每个nginx机器上部署一个flume的客户端，将我们关心的日志文件写到到flume的配置文件中，具体的配置可以自行网上查找。</p><h4 id="遇到的问题及解决办法"><a href="#遇到的问题及解决办法" class="headerlink" title="遇到的问题及解决办法"></a>遇到的问题及解决办法</h4><p>1、flume的服务挂了 日志数据怎么办？<br>可以采用将服务以守护进程的方式启动，监控进程的状态，日志是后端和nginx实时打在磁盘的，所以就算服务挂了，重启后也是可以读取到日志的对应位置。或者将flume的channel配置成file，就不会出现日志数据丢失的问题。</p><p>2、监听的文件fd换了 怎么监控？<br>flume监控的是文件名，并不是fd，所以当原始日志切换切分时，新创建的日志文件只要名称不变，还是可以监控到。</p><p>3、当flume的sink配置的是hdfs时，可以选择将数据压缩。flume支持通用的压缩算法。我们采用了gzip的压缩算法，比不压缩节省约70%的磁盘空间。</p><h4 id="最最最重要的问题来了"><a href="#最最最重要的问题来了" class="headerlink" title="最最最重要的问题来了"></a>最最最重要的问题来了</h4><p>在flume的sink配置的是hdfs时，请做以下操作，顺序无所谓：</p><ul><li>flume使用的是hadoop和hdfs中的lib目录下的jar包，所以需要将对应的jar包导入到flume的lib目录下；</li><li>导入core-site.xml和hdfs-site.xml文件，如果文件中配置的是hadoop节点的名字，需要将名字和对应的机器ip配置到/etc/hosts中，不然flume找不到；</li><li>一定要将hadoop集群中的native目录导入到flume服务端所在机器的环境变量中，命令 export ~/flume/native。原因是Hadoop是使用Java开发的，但是有一些需求和操作并不适合使用java，所以就引入了本地库的概念，通过本地库，Hadoop可以更加高效地执行某一些操作。</li></ul><p>没有导入的时候一般的操作没有什么问题，但是，使用gzip做数据压缩时就会出现系统环境的问题，导致hadoop集群上hive不能正确的解压缩数据。<br>没有导入native时，gzip压缩的文件使用file查看文件类型时是: gzip compressed data, from FAT filesystem (MS-DOS, OS/2, NT)<br>导入后，gzip压缩的文件使用file查看文件类型时是: gzip compressed data, from Unix。这才是我们想要的压缩文件。<br>所以，一定要导入native！！！千万不要踩坑！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;什么是flume？&quot;&gt;&lt;a href=&quot;#什么是flume？&quot; class=&quot;headerlink&quot; title=&quot;什么是flume？&quot;&gt;&lt;/a&gt;什么是flume？&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;flume是一个日志采集、聚合和传输的系统&lt;/p&gt;
&lt;p&gt;&lt;img
      
    
    </summary>
    
    
      <category term="flume" scheme="http://yoursite.com/categories/flume/"/>
    
    
      <category term="flume" scheme="http://yoursite.com/tags/flume/"/>
    
  </entry>
  
  <entry>
    <title>hdfs Cannot obtain block length for LocatedBlock异常的解决</title>
    <link href="http://yoursite.com/2020/05/11/%E4%BB%8E0%E5%AD%A6java%E7%AC%AC1%E7%AF%87-%E5%AF%B9java%E7%9A%84%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/05/11/%E4%BB%8E0%E5%AD%A6java%E7%AC%AC1%E7%AF%87-%E5%AF%B9java%E7%9A%84%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3/</id>
    <published>2020-05-11T15:36:00.000Z</published>
    <updated>2020-05-11T15:39:19.613Z</updated>
    
    <content type="html"><![CDATA[<h4 id="问题的发现"><a href="#问题的发现" class="headerlink" title="问题的发现"></a>问题的发现</h4><p>在备份hdfs的数据到本地磁盘时，使用了get命令，结果报错了，具体的错误就是Cannot obtain block length for LocatedBlock这个异常。发现这个问题之后就开始解决问题。</p><h4 id="问题出现的原因"><a href="#问题出现的原因" class="headerlink" title="问题出现的原因"></a>问题出现的原因</h4><p>写hdfs的上游是flume，所以就去查出错数据当天是否调整过flume服务。通过flume的日志发现当天有写hdfs时候，datanode没有响应的错误日志，正在写的日志文件就没有正常的关闭。</p><p>这里就出现了hdfs的租约未被释放的问题，租约就是<code>在HDFS中，当每次客户端用户往某个文件中写入数据的时候，为了保持数据的一致性，此时其它客户端程序是不允许向此文件同时写入数据的</code>，租约的信息是存在namenode中的，也就是说当hdfs系统被关闭时，flume还在继续写该文件，同时也会报错，文件还是处于打开状态。</p><p>所以我们要解决这个问题就需要释放租约。</p><h4 id="恢复租约的方式"><a href="#恢复租约的方式" class="headerlink" title="恢复租约的方式"></a>恢复租约的方式</h4><p>首先先查看有哪些文件是租约没有释放的<br><code>hadoop fsck /hafs/path -openforwrite</code><br>然后执行<br><code>hdfs debug recoverLease -path</code><br>释放租约</p><p>如果未被释放租约的文件太多的话，可以执行批量释放操作<br><code>hadoop fsck /hafs/path -openforwrite | egrep -v &#39;^\.+$&#39; | egrep &quot;MISSING|OPENFORWRITE&quot; | grep -o &quot;/[^ ]*&quot; | sed -e &quot;s/:$//&quot; | xargs -i hdfs debug recoverLease -path {}</code></p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>该问题的出现主要是下游关闭时上游还在写，导致租约没有释放掉。在以后的升级或者重启hdfs时，需要提前先把flume或者其他上游写hdfs操作停止后，在执行hdfs系统的操作，才可以避免该问题的出现。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;问题的发现&quot;&gt;&lt;a href=&quot;#问题的发现&quot; class=&quot;headerlink&quot; title=&quot;问题的发现&quot;&gt;&lt;/a&gt;问题的发现&lt;/h4&gt;&lt;p&gt;在备份hdfs的数据到本地磁盘时，使用了get命令，结果报错了，具体的错误就是Cannot obtain block
      
    
    </summary>
    
    
      <category term="hadoop" scheme="http://yoursite.com/categories/hadoop/"/>
    
    
      <category term="hadoop" scheme="http://yoursite.com/tags/hadoop/"/>
    
      <category term="hdfs" scheme="http://yoursite.com/tags/hdfs/"/>
    
      <category term="文件租约" scheme="http://yoursite.com/tags/%E6%96%87%E4%BB%B6%E7%A7%9F%E7%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>从0学java第1篇--对java的粗浅理解</title>
    <link href="http://yoursite.com/2020/05/11/%E4%BB%8E0%E5%AD%A6java%E7%AC%AC1%E7%AF%87-%E5%AF%B9java%E7%9A%84%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3-1/"/>
    <id>http://yoursite.com/2020/05/11/%E4%BB%8E0%E5%AD%A6java%E7%AC%AC1%E7%AF%87-%E5%AF%B9java%E7%9A%84%E7%B2%97%E6%B5%85%E7%90%86%E8%A7%A3-1/</id>
    <published>2020-05-11T15:35:00.000Z</published>
    <updated>2020-05-11T15:36:25.309Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对java的粗浅理解"><a href="#对java的粗浅理解" class="headerlink" title="对java的粗浅理解"></a>对java的粗浅理解</h3><p>对java有过简单了解的人都听说过java是”一次书写，到处运行”这一大特点，这个说的就是java的跨平台的特性。但是这种特性并不只是java才有的，java只是比较成熟一些而已。</p><p>所谓的”一次书写，到处运行”指的是我们编写好的程序，通过javac编译后，变成<em>.class文件的字节码，</em>.class就是可以到处运行的文件，但是这种文件不可以直接在机器上执行，需要使用jvm这种跨平台的抽象环境，将字节码转化成目标机器代码，这样就可以实现导出运行了。</p><h3 id="编译执行还是解释执行？"><a href="#编译执行还是解释执行？" class="headerlink" title="编译执行还是解释执行？"></a>编译执行还是解释执行？</h3><p>对java而言，在程序执行的时候，jvm将字节码解释成机器可以识别的机器码。但是在我们通常使用的jvm中，都提供了 JIT（Just-In-Time）编译器，JIT可以在运行的时候将热点代码编译成机器码，这种情况下热点代码就属于编译执行了。</p><h3 id="常见的名词"><a href="#常见的名词" class="headerlink" title="常见的名词"></a>常见的名词</h3><p>在开发过程中我们经常会听到javac、jvm、jre、jdk这些名词，我们理一下他们都是什么。</p><ul><li><p>javac是一个编译器，用于将我们编写好的代码编译成以.class为后缀的字节码。</p></li><li><p>jvm就是java虚拟机，我们写好的代码并不直接在真实的目标机器上执行，而是通过javac编译后生成字节码，java虚拟机会把这些字节码解释成目标机器可以识别的机器码执行。</p></li><li><p>jre就是java运行的环境，在jvm解释字节码的时候，jvm需要调用一些解释所必须的类库，这些必要的类库都是在jre的lib中。所以可以简单的理解为jre包含jvm和所需的lib两部分。</p></li><li><p>jdk是java的一个开发工具包，我们在开发java程序之前，都会安装一个jdk，jdk主要包含javac、jre和一些类库。</p></li></ul><p>以上的关系可以看出，jdk包含了jre，jre包含了jvm。jdk包含了编译必须使用的javac。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对java的粗浅理解&quot;&gt;&lt;a href=&quot;#对java的粗浅理解&quot; class=&quot;headerlink&quot; title=&quot;对java的粗浅理解&quot;&gt;&lt;/a&gt;对java的粗浅理解&lt;/h3&gt;&lt;p&gt;对java有过简单了解的人都听说过java是”一次书写，到处运行”这一大特点
      
    
    </summary>
    
    
      <category term="java" scheme="http://yoursite.com/categories/java/"/>
    
    
      <category term="java" scheme="http://yoursite.com/tags/java/"/>
    
      <category term="jvm" scheme="http://yoursite.com/tags/jvm/"/>
    
  </entry>
  
  <entry>
    <title>google的tensor2tensor的学习和使用</title>
    <link href="http://yoursite.com/2020/05/11/google%E7%9A%84tensor2tensor%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8/"/>
    <id>http://yoursite.com/2020/05/11/google%E7%9A%84tensor2tensor%E7%9A%84%E5%AD%A6%E4%B9%A0%E5%92%8C%E4%BD%BF%E7%94%A8/</id>
    <published>2020-05-11T15:25:00.000Z</published>
    <updated>2020-05-11T15:33:17.148Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><ul><li>tensor2tensor（t2t）是google基于tensorflow新开源的深度学习库，该库将深度学习所需要的元素（数据集、模型、学习率、超参数等）封装成标准化的统一接口，在使用其做模型训练时可以更加的灵活。</li></ul><h3 id="当前环境"><a href="#当前环境" class="headerlink" title="当前环境"></a>当前环境</h3><ul><li>mac 10.13.3</li><li>tensorflow 1.6.0</li><li>tensor2tensor 1.5.5</li></ul><h3 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h3><ul><li>源码下载：<a href="https://github.com/tensorflow/tensor2tensor" target="_blank" rel="noopener">https://github.com/tensorflow/tensor2tensor</a></li><li>sudo pip install tensorflow==1.6.0</li><li>sudo pip install tensor2tensor==1.5.5</li></ul><h3 id="开启学习之旅"><a href="#开启学习之旅" class="headerlink" title="开启学习之旅"></a>开启学习之旅</h3><p>在下载的源码中有自带的一些简单的测试样例。如mnist,，可以参考<a href="https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/notebooks/hello_t2t.ipynb" target="_blank" rel="noopener">https://github.com/tensorflow/tensor2tensor/blob/master/tensor2tensor/notebooks/hello_t2t.ipynb</a><br>来做初步的了解。</p><p>同时t2t支持自定义的样本数据和自定义的参数配置，下面以我自定义了一个训练样本开始介绍。</p><p>已将下述的代码上传：<a href="https://download.csdn.net/download/csa121/10672326" target="_blank" rel="noopener">https://download.csdn.net/download/csa121/10672326</a><br>根据下述的介绍也可以自己搭建一个环境的。</p><h4 id="0-目录结构"><a href="#0-目录结构" class="headerlink" title="0.目录结构"></a>0.目录结构</h4><p>因为有需要注意的点，先看下我自定义样本的目录结构：<br><img src="http://img.blog.csdn.net/20180318200525009?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NhMTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="目录结构"></p><p>decoder：预测要用到的目录<br>rawdata：原始样本存放的目录<br>self_data：原始样本格式化后存放的目录<br>self_script：自定义problem脚本存放的目录<br>train：训练出来的模型和导出的模型存放的目录</p><p>注：只是为了后续介绍的更清楚才说明的目录结构，不是t2t要求的目录结构。</p><h4 id="1-需求"><a href="#1-需求" class="headerlink" title="1.需求"></a>1.需求</h4><p>训练一些评论和标签样本，生成一个模型，可以给新的评论打一个标签</p><h4 id="2-样本"><a href="#2-样本" class="headerlink" title="2.样本"></a>2.样本</h4><p>评论样本 rawdata/q.txt：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">内容很多很棒</span><br><span class="line">好老师！有耐心！培养孩子兴趣！赞一个</span><br><span class="line">课程很精彩，老师会结合自身作为案例进行分享</span><br><span class="line">老师很幽默</span><br><span class="line">老师的能力值得肯定</span><br><span class="line">喜欢上老师的数学课</span><br><span class="line">老师上课气氛特别好</span><br><span class="line">每次听完老师的课都觉得让自己又丰富了许多</span><br><span class="line">挺善于沟通的,比较容易接受</span><br><span class="line">观点很新颖,谢谢老师</span><br></pre></td></tr></table></figure><p>标签样本 rawdata/a.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">授课熟练</span><br><span class="line">态度认真负责</span><br><span class="line">授课熟练</span><br><span class="line">幽默风趣</span><br><span class="line">性价比高</span><br><span class="line">幽默风趣</span><br><span class="line">上课气氛活跃</span><br><span class="line">内容新颖有用</span><br><span class="line">性价比高</span><br><span class="line">内容新颖有用</span><br></pre></td></tr></table></figure><h4 id="3-编写自定义的problem"><a href="#3-编写自定义的problem" class="headerlink" title="3.编写自定义的problem"></a>3.编写自定义的problem</h4><p>self_script/my_problem.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"># coding&#x3D;utf-8</span><br><span class="line">from tensor2tensor.utils import registry</span><br><span class="line">from tensor2tensor.data_generators import problem, text_problems</span><br><span class="line"></span><br><span class="line">#自定义的problem一定要加该装饰器，不然t2t库找不到自定义的problem</span><br><span class="line">@registry.register_problem</span><br><span class="line">class MyProblem(text_problems.Text2TextProblem):</span><br><span class="line">    @property</span><br><span class="line">    def approx_vocab_size(self):</span><br><span class="line">        return 2**11</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def is_generate_per_split(self):</span><br><span class="line">        return False</span><br><span class="line"></span><br><span class="line">    @property</span><br><span class="line">    def dataset_splits(self):</span><br><span class="line">        return [&#123;</span><br><span class="line">            &quot;split&quot;: problem.DatasetSplit.TRAIN,</span><br><span class="line">            &quot;shards&quot;: 9,</span><br><span class="line">        &#125;, &#123;</span><br><span class="line">            &quot;split&quot;: problem.DatasetSplit.EVAL,</span><br><span class="line">            &quot;shards&quot;: 1,</span><br><span class="line">        &#125;]</span><br><span class="line"></span><br><span class="line">    def generate_samples(self, data_dir, tmp_dir, dataset_split):</span><br><span class="line">        del data_dir</span><br><span class="line">        del tmp_dir</span><br><span class="line">        del dataset_split</span><br><span class="line">#读取原始的训练样本数据</span><br><span class="line">        q_r &#x3D; open(&quot;.&#x2F;rawdata&#x2F;q.txt&quot;, &quot;r&quot;)</span><br><span class="line">        a_r &#x3D; open(&quot;.&#x2F;rawdata&#x2F;a.txt&quot;, &quot;r&quot;)</span><br><span class="line"></span><br><span class="line">        comment_list &#x3D; q_r.readlines()</span><br><span class="line">        tag_list &#x3D; a_r.readlines()</span><br><span class="line">        q_r.close()</span><br><span class="line">        a_r.close()</span><br><span class="line">        for comment, tag in zip(comment_list, tag_list):</span><br><span class="line">            comment &#x3D; comment.strip()</span><br><span class="line">            tag &#x3D; tag.strip()</span><br><span class="line">            yield &#123;</span><br><span class="line">                &quot;inputs&quot;: comment,</span><br><span class="line">                &quot;targets&quot;: tag</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><p>self_script/<strong>init</strong>.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from . import my_problem</span><br></pre></td></tr></table></figure><p>需要注意的点：<br>（1）一定要在<strong>init</strong>.py文件中引入模块，否则t2t的命令找不到自定义的problem；</p><p>（2）自定义的problem文件名一定要和脚本中的class名保持一致，如：文件名是my_problem，类名需要是MyProblem，否则t2t的命令找不到自定义的problem。希望后续的版本不会有这个问题吧。</p><h4 id="4-格式化样本"><a href="#4-格式化样本" class="headerlink" title="4.格式化样本"></a>4.格式化样本</h4><p>要将原始的样本数据转换成t2t自己的数据集格式（TFRecord），使用t2t-datagen命令执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t2t-datagen --t2t_usr_dir&#x3D;self_script --problem&#x3D;my_problem --data_dir&#x3D;.&#x2F;self_data</span><br></pre></td></tr></table></figure><p>格式化的数据会在self_data目录下生成一些文件如下：</p><p><img src="http://img.blog.csdn.net/20180318202301389?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NhMTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="格式化数据文件"></p><p>后续我们的训练就是读这些文件。</p><h4 id="5-训练"><a href="#5-训练" class="headerlink" title="5.训练"></a>5.训练</h4><p>使用t2t-trainer命令对格式化样本进行训练：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t2t-trainer --t2t_usr_dir&#x3D;self_script --problem&#x3D;my_problem --data_dir&#x3D;.&#x2F;self_data --model&#x3D;lstm_seq2seq_attention --hparams_set&#x3D;lstm_attention --output_dir&#x3D;.&#x2F;train</span><br></pre></td></tr></table></figure><p>我们使用的模型是lstm_seq2seq_attention模型，使用的超参数集是lstm_attention。因为还在学习阶段，就没有特地去选择模型。</p><p>需要注意的点：<br>（1）如果在训练过程中有如下报错：</p><p><img src="http://img.blog.csdn.net/20180318203105033?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY3NhMTIx/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="训练报错"></p><p>说明当前tensor2tensor和tensorflow的版本兼容有问题，需要更换两者的版本，经过查阅tensor2tensor在github的代码提交和其他信息，试验出来tensor2tensor==1.5.3和tensorflow==1.4.1这两个版本组合是没有问题的。有报错的可以把两者版本降低一下。</p><p>（2）在训练过程中我没有指定训练的次数和打印准确率的步数，t2t默认是训练1000次打印一次准确率。如果感觉准确率符合预期的话，可以直接kill掉训练任务。t2t会自动保存最新的训练模型。</p><h4 id="6-预测"><a href="#6-预测" class="headerlink" title="6.预测"></a>6.预测</h4><p>使用t2t-decoder命令对训练好的样本进行预测<br>先看下预测的样本：<br>decoder/q.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">老师很幽默</span><br><span class="line">非常好 讲的很详细 很幽默哈哈哈</span><br><span class="line">第一次听！讲得还挺清楚，只是不清楚后面怎么安排呢</span><br></pre></td></tr></table></figure><p>预测是命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t2t-decoder --t2t_usr_dir&#x3D;self_script --problem&#x3D;my_problem --data_dir&#x3D;.&#x2F;self_data --model&#x3D;lstm_seq2seq_attention --hparams_set&#x3D;lstm_attention --output_dir&#x3D;.&#x2F;train --decode_hparams&#x3D;&quot;beam_size&#x3D;4,alpha&#x3D;0.6&quot; --decode_from_file&#x3D;decoder&#x2F;q.txt --decode_to_file&#x3D;decoder&#x2F;a.txt</span><br></pre></td></tr></table></figure><p>可以在你指定的decode_to_file文件下看到预测的结果是否符合预期</p><h4 id="7-导出模型"><a href="#7-导出模型" class="headerlink" title="7.导出模型"></a>7.导出模型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t2t-exporter --t2t_usr_dir&#x3D;self_script --problems&#x3D;my_problem --data_dir&#x3D;.&#x2F;self_data --model&#x3D;lstm_seq2seq_attention --hparams_set&#x3D;lstm_attention --output_dir&#x3D;.&#x2F;train</span><br></pre></td></tr></table></figure><p>需要注意的点：<br>（1）github中t2t的源码中有提到导出功能只支持tensorflow 1.5+，所以如果在训练过程中有降低了tensorflow版本的操作，还需要把版本升到1.5+；</p><p>（2）注意导出命令中的<strong>problems</strong>=my_problem参数，前面训练时使用的是<strong>problem</strong>=my_problem，<strong>导出时需要加problem参数名要加s</strong>。不知道t2t中为什么会存在这种不兼容的情况，希望后续会修复这个参数的问题吧。</p><h4 id="8-搭建一个常驻内存的预测服务"><a href="#8-搭建一个常驻内存的预测服务" class="headerlink" title="8.搭建一个常驻内存的预测服务"></a>8.搭建一个常驻内存的预测服务</h4><p>搭建服务时请确保mac上安装了brew，没有安装的请先自行安装brew。后续步骤如下：<br>（1）安装tensorflow-serving-api</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip install tensorflow-serving-api</span><br></pre></td></tr></table></figure><p>（2）安装Bazel<br>bazel是google的一个编译工具，类似于Make。我们需要使用它对源码进行编译出一个tensorflow_model_server二进制文件。执行：brew install bazel</p><p>（3）下载serving源码<br>我们需要使用bazel对源码进行编译，所以需要先下载该源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone --recurse-submodules https:&#x2F;&#x2F;github.com&#x2F;tensorflow&#x2F;serving</span><br></pre></td></tr></table></figure><p>（4）创建tensorflow_serving</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd serving</span><br><span class="line">bazel build tensorflow_serving&#x2F;</span><br></pre></td></tr></table></figure><p>（5）编译出一个用来启动服务的tensorflow_model_server的二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bazel build -c opt &#x2F;&#x2F;tensorflow_serving&#x2F;model_servers:tensorflow_model_server</span><br></pre></td></tr></table></figure><p>注：时间比较长，编译大概用了一个多小时吧</p><p>（6）配置命令<br>将tensorflow_model_server命令起个别名指定到目录，这样就不用在特定的目录下执行启动服务的操作了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vim ~&#x2F;.bashrc</span><br><span class="line">alias tensorflow_model_server&#x3D;&#39;~&#x2F;serving&#x2F;bazel-bin&#x2F;tensorflow_serving&#x2F;model_servers&#x2F;tensorflow_model_server&#39;</span><br><span class="line">source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure><p>（7）启动server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tensorflow_model_server --port&#x3D;9000 --model_name&#x3D;lstm_seq2seq_attention --model_base_path&#x3D;~&#x2F;self_t2t&#x2F;train&#x2F;export&#x2F;Servo</span><br></pre></td></tr></table></figure><p>经过以上的步骤，就可以启动一个常驻内存的预测服务了。</p><h4 id="9-客户端发请求预测"><a href="#9-客户端发请求预测" class="headerlink" title="9.客户端发请求预测"></a>9.客户端发请求预测</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t2t-query-server --server&#x3D;127.0.0.1:9000 --servable_name&#x3D;lstm_seq2seq_attention --t2t_usr_dir&#x3D;self_script --problem&#x3D;my_problem --data_dir&#x3D;.&#x2F;self_data</span><br></pre></td></tr></table></figure><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><ul><li><p>经过上述的所有操作，对t2t的使用上有了一个初步的了解，在后续的使用中可以根据各自不同的业务场景自定义不同的problem、更换model和hparams。</p></li><li><p>在使用的过程中，发现目前t2t和tf的版本间兼容性还不是很好，相信后续应该会更完善吧。</p></li><li><p>虽然t2t将现有的一些主流模型做了封装，我们可以不用关注模型的生成，但是我们也有必要多了解其背后的实现原理。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;tensor2tensor（t2t）是google基于tensorflow新开源的深度学习库，该库将深度学习所需要的元素（数据集
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://yoursite.com/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="tensorflow" scheme="http://yoursite.com/tags/tensorflow/"/>
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="tensor2tensor" scheme="http://yoursite.com/tags/tensor2tensor/"/>
    
  </entry>
  
  <entry>
    <title>小白学django搭建网站</title>
    <link href="http://yoursite.com/2020/05/10/django%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/05/10/django%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-10T07:51:00.000Z</published>
    <updated>2020-05-11T15:41:40.558Z</updated>
    
    <content type="html"><![CDATA[<p>django是一个python语言开发的web框架。<br>主要的组件以及特点</p><ul><li>强大的数据库功能</li><li>自带后台管理功能</li><li>优雅的网址</li><li>模板系统</li><li>缓存系统</li><li>国际化</li></ul><h3 id="1-搭建项目"><a href="#1-搭建项目" class="headerlink" title="1 搭建项目"></a>1 搭建项目</h3><p>安装python2.7或者python3均可，安装pip（默认都有啦）</p><h4 id="1-1-安装django"><a href="#1-1-安装django" class="headerlink" title="1.1 安装django"></a>1.1 安装django</h4><p>默认安装最新版</p><p><code>(sudo) pip install django</code></p><p>指定版本安装</p><p><code>(sudo) pip install django==1.11.11</code></p><p>安装如果遇到速度太慢或者超时，可以使用国内镜像安装</p><p><code>(sudo) pip install django -i https://pypi.doubanio.com/simple/</code></p><p>安装后就可以下一步搭建项目</p><h4 id="1-2-创建一个django项目"><a href="#1-2-创建一个django项目" class="headerlink" title="1.2 创建一个django项目"></a>1.2 创建一个django项目</h4><h5 id="1-2-1-创建一个项目目录（已有也行）"><a href="#1-2-1-创建一个项目目录（已有也行）" class="headerlink" title="1.2.1 创建一个项目目录（已有也行）"></a>1.2.1 创建一个项目目录（已有也行）</h5><p><code>mkdir django_test</code></p><h5 id="1-2-2-进入该目录"><a href="#1-2-2-进入该目录" class="headerlink" title="1.2.2 进入该目录"></a>1.2.2 进入该目录</h5><p><code>cd django_test</code></p><h5 id="1-2-3-执行该命令创建一个django项目"><a href="#1-2-3-执行该命令创建一个django项目" class="headerlink" title="1.2.3 执行该命令创建一个django项目"></a>1.2.3 执行该命令创建一个django项目</h5><p><code>django-admin.py startproject family</code></p><h5 id="1-2-4-进入family目录后执行"><a href="#1-2-4-进入family目录后执行" class="headerlink" title="1.2.4 进入family目录后执行"></a>1.2.4 进入family目录后执行</h5><p><code>python manage.py runserver</code> 或者指定端口 <code>python manage.py runserver 8081</code></p><p>在浏览器输入 <a href="http://127.0.0.1:8000/" target="_blank" rel="noopener">http://127.0.0.1:8000/</a> 就可以打开看到 It worked! 字样，表示django项目创建成功</p><h4 id="1-3-创建一个django工程"><a href="#1-3-创建一个django工程" class="headerlink" title="1.3 创建一个django工程"></a>1.3 创建一个django工程</h4><p><code>python manage.py startapp family_app</code></p><p>注意点：工程名中不能有中划线</p><h4 id="1-4-配置我们的工程"><a href="#1-4-配置我们的工程" class="headerlink" title="1.4 配置我们的工程"></a>1.4 配置我们的工程</h4><p>需要在family/settings.py中做一些配置</p><h5 id="1-4-1-INSTALLED-APPS列表中注册我们的工程名"><a href="#1-4-1-INSTALLED-APPS列表中注册我们的工程名" class="headerlink" title="1.4.1 INSTALLED_APPS列表中注册我们的工程名"></a>1.4.1 INSTALLED_APPS列表中注册我们的工程名</h5><h5 id="1-4-2-配置数据库-mysql"><a href="#1-4-2-配置数据库-mysql" class="headerlink" title="1.4.2 配置数据库(mysql)"></a>1.4.2 配置数据库(mysql)</h5><p>默认我们本地都安装了mysql（建议5.6+）<br>在DATABASES字典中注释掉自带的数据库，使用我们自己配置的mysql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"> &#39;default&#39;: &#123;</span><br><span class="line">    &#39;ENGINE&#39;: &#39;django.db.backends.mysql&#39;,</span><br><span class="line">    &#39;NAME&#39;: &#39;family_app&#39;,</span><br><span class="line">    &#39;USER&#39;: &#39;wanglei&#39;,</span><br><span class="line">    &#39;PASSWORD&#39;: &#39;xxxxxx&#39;,</span><br><span class="line">    &#39;HOST&#39;: &#39;127.0.0.1&#39;,</span><br><span class="line">    &#39;PORT&#39;: &#39;3306&#39;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>注意点：如果mysql版本是5.7+，需要在family/<strong>init</strong>.py中加入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">import pymysql</span><br><span class="line">pymysql.install_as_MySQLdb()</span><br></pre></td></tr></table></figure><p>原因是直接使用mysql和mysqlDb的不兼容，不能直接使用mysqlDb模块，需要使用pymysql替代</p><h5 id="1-4-3-数据库中创建一些django自带的表"><a href="#1-4-3-数据库中创建一些django自带的表" class="headerlink" title="1.4.3 数据库中创建一些django自带的表"></a>1.4.3 数据库中创建一些django自带的表</h5><p><code>python manage.py migrate</code></p><p>到此为止，整个项目和工程的基本配置就完成了。</p><h3 id="2-helloWorld起步"><a href="#2-helloWorld起步" class="headerlink" title="2 helloWorld起步"></a>2 helloWorld起步</h3><h4 id="2-1-工程中的文件结构介绍"><a href="#2-1-工程中的文件结构介绍" class="headerlink" title="2.1 工程中的文件结构介绍"></a>2.1 工程中的文件结构介绍</h4><ul><li>migrations：数据迁移模块</li><li>admin.py：后台管理系统</li><li>apps.py：应用的一些配置，1.9以后自动生成</li><li>models.py：数据模块</li><li>tests.py：自动化测试的模块</li><li>views.py：执行响应的代码所在模块，是代码逻辑处理的主要地点，项目中大部分代码在这里编写</li></ul><h4 id="2-2-第一行代码"><a href="#2-2-第一行代码" class="headerlink" title="2.2 第一行代码"></a>2.2 第一行代码</h4><ul><li><p>在family/urls.py中引入我们工程中的views，然后配置路由</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import family_app.views as views</span><br><span class="line">urlpatterns &#x3D; [</span><br><span class="line">    url(r&#39;^admin&#x2F;&#39;, admin.site.urls),</span><br><span class="line">    url(r&#39;^$&#39;, views.index),</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>family_app/views.py中写我们要展示在界面的逻辑</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">from django.http import HttpResponse, JsonResponse</span><br><span class="line">def index(request):</span><br><span class="line">    ret_str &#x3D; &quot;hello world&quot;</span><br><span class="line">    print ret_str</span><br><span class="line">    return HttpResponse(ret_str)</span><br></pre></td></tr></table></figure></li><li><p>刷新界面，就可以看到hello world了</p></li></ul><h3 id="3-渲染模板"><a href="#3-渲染模板" class="headerlink" title="3 渲染模板"></a>3 渲染模板</h3><h4 id="3-1-模板渲染入门"><a href="#3-1-模板渲染入门" class="headerlink" title="3.1 模板渲染入门"></a>3.1 模板渲染入门</h4><p>将后端返回的结构化数据渲染到模板上</p><ul><li><p>在family_app目录下创建templates目录，管理前端模板</p></li><li><p>在family/settings.py的TEMPLATES中DIRS列表中加入’family_app/templates’</p></li><li><p>在templates目录下创建index.html文件，并写代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">        &lt;h3&gt;这就是后端返回的数据 &#123;&#123; data &#125;&#125;&lt;&#x2F;h3&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure></li><li><p>family_app/views.py中修改响应的方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return render(request, &#39;index.html&#39;, &#123;&#39;data&#39;: ret_str&#125;)</span><br></pre></td></tr></table></figure><p>一个简单的模板渲染就完成了</p></li></ul><h4 id="3-2-一些基础的渲染方式"><a href="#3-2-一些基础的渲染方式" class="headerlink" title="3.2 一些基础的渲染方式"></a>3.2 一些基础的渲染方式</h4><ul><li>列表渲染</li></ul><p>family_app/views.py</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret_str &#x3D; [&quot;hello world&quot;, &quot;1024&quot;]</span><br><span class="line">return render(request, &#39;index.html&#39;, &#123;&#39;data&#39;: ret_str&#125;)</span><br></pre></td></tr></table></figure><p>templates/index.html</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% for item in data %&#125;</span><br><span class="line">        &lt;p&gt;&#123;&#123; item &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><ul><li>字典渲染<br>family_app/views.py<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ret_str &#x3D; &#123;&quot;k1&quot;: &quot;hello&quot;, &quot;k2&quot;: &quot;world&quot;, &quot;k3&quot;: &quot;1024&quot;&#125;</span><br><span class="line">return render(request, &#39;index.html&#39;, &#123;&#39;data&#39;: ret_str&#125;)</span><br></pre></td></tr></table></figure>templates/index.html<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">遍历取值</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% for key, val in data.items %&#125;</span><br><span class="line">        &lt;p&gt;key:&#123;&#123; key &#125;&#125; val:&#123;&#123; val &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line">按key取值</span><br><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;&#123; data.k3 &#125;&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li></ul><p>4 包含静态资源的模板渲染</p><p>在以上的基础上，我们加上js和css的操作</p><ul><li><p>在family_app目录下创建static目录，管理静态资源</p></li><li><p>在family/settings.py中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STATIC_ROOT &#x3D; os.path.join(BASE_DIR, &quot;family_app&#x2F;static&quot;)</span><br></pre></td></tr></table></figure></li><li><p>在family_app/static/index.js，并添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function click_submit()</span><br><span class="line">&#123;</span><br><span class="line">    alert(&quot;别点了！&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在family_app/static/index.css，并添加代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.list-css &#123;</span><br><span class="line">    margin-left:200px;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在index.html中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% load static %&#125;</span><br><span class="line">&lt;link rel&#x3D;&quot;stylesheet&quot; href&#x3D;&quot;&#123;% static &#39;index.css&#39; %&#125;&quot; type&#x3D;&quot;text&#x2F;css&quot;&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;static&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;div onclick&#x3D;&quot;click_submit()&quot;&gt;点击按钮&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure></li></ul><p>以上就是前端静态资源在页面加载过程中的具体配置方式</p><h3 id="4-后端请求数据库"><a href="#4-后端请求数据库" class="headerlink" title="4 后端请求数据库"></a>4 后端请求数据库</h3><p>先不使用django的model，我们自己连接数据库去请求</p><h4 id="4-1-创建数据库表并写几条数据进去"><a href="#4-1-创建数据库表并写几条数据进去" class="headerlink" title="4.1 创建数据库表并写几条数据进去"></a>4.1 创建数据库表并写几条数据进去</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">create table family_app.user (</span><br><span class="line">  id int(11) NOT NULL AUTO_INCREMENT,</span><br><span class="line">  number bigint(20) NOT NULL COMMENT &#39;用户编号&#39;,</span><br><span class="line">  name varchar(45) DEFAULT NULL COMMENT &#39;用户名&#39;,</span><br><span class="line">  mobile varchar(20) DEFAULT NULL COMMENT &#39;手机号&#39;,</span><br><span class="line">  status tinyint(4) DEFAULT &#39;1&#39; COMMENT &#39;用户状态&#39;,</span><br><span class="line">  create_time timestamp DEFAULT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;创建时间&#39;,</span><br><span class="line">  update_time timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;更新时间&#39;,</span><br><span class="line">  PRIMARY KEY (id),</span><br><span class="line">  UNIQUE KEY uniq_number (number),</span><br><span class="line">  KEY idx_mobile (mobile),</span><br><span class="line">  KEY idx_update_time (update_time)</span><br><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;0 DEFAULT CHARSET&#x3D;utf8 COMMENT&#x3D;&quot;用户表&quot;;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">insert into family_app.user (number, name, mobile, status) values (1000, &quot;张三&quot;, &quot;13100000000&quot;, 1);</span><br></pre></td></tr></table></figure><h4 id="4-2-连接数据库并写sql请求数据"><a href="#4-2-连接数据库并写sql请求数据" class="headerlink" title="4.2 连接数据库并写sql请求数据"></a>4.2 连接数据库并写sql请求数据</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">from django.db import connection, models</span><br><span class="line">import traceback</span><br><span class="line"></span><br><span class="line">def get_user_info(request):</span><br><span class="line">    number &#x3D; 0</span><br><span class="line">    if &#39;number&#39; in request.GET and request.GET[&#39;number&#39;] !&#x3D; 0:</span><br><span class="line">        number &#x3D; int(request.GET[&#39;number&#39;])</span><br><span class="line"></span><br><span class="line">    user_sql &#x3D; &quot;&quot;&quot;</span><br><span class="line">        select number, name, mobile from family_app.user where status&#x3D;1 and number&#x3D;%s</span><br><span class="line">    &quot;&quot;&quot; % number</span><br><span class="line">    print &quot;user_sql:&quot;, user_sql</span><br><span class="line">    ret &#x3D; execute(user_sql)</span><br><span class="line"></span><br><span class="line">    ret_list &#x3D; []</span><br><span class="line">    for r in ret:</span><br><span class="line">        print r[0], r[1], r[2]</span><br><span class="line">        user_dict &#x3D; &#123;&quot;number&quot;: r[0], &quot;name&quot;: r[1], &quot;mobile&quot;: r[2]&#125;</span><br><span class="line">        ret_list.append(user_dict)</span><br><span class="line">    return render(request, &#39;index.html&#39;, &#123;&#39;data&#39;: ret_list&#125;)</span><br><span class="line"></span><br><span class="line">def execute(sql, params&#x3D;None, auto_close&#x3D;True):</span><br><span class="line">    cur &#x3D; None</span><br><span class="line">    try:</span><br><span class="line">        sql &#x3D; sql.strip()</span><br><span class="line">        cur &#x3D; connection.cursor()</span><br><span class="line">        cur.execute(sql, params)</span><br><span class="line">        result &#x3D; cur.fetchall()</span><br><span class="line">        #print &quot;ret_len:&quot;, len(result)</span><br><span class="line">        return result</span><br><span class="line">    except Exception, e:</span><br><span class="line">        if params:</span><br><span class="line">            print sql % params</span><br><span class="line">        else:</span><br><span class="line">            print sql</span><br><span class="line">        traceback.print_exc()</span><br><span class="line">    finally:</span><br><span class="line">        if cur and auto_close:</span><br><span class="line">            cur.close()</span><br></pre></td></tr></table></figure><h4 id="4-3-url配置接口名"><a href="#4-3-url配置接口名" class="headerlink" title="4.3 url配置接口名"></a>4.3 url配置接口名</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">url(r&#39;^get_user_info&#39;, views.get_user_info)</span><br></pre></td></tr></table></figure><h4 id="4-4-index-html中写渲染代码"><a href="#4-4-index-html中写渲染代码" class="headerlink" title="4.4 index.html中写渲染代码"></a>4.4 index.html中写渲染代码</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">    &#123;% for item_dict in data %&#125;</span><br><span class="line">        &#123;% for key, val in item_dict.items %&#125;</span><br><span class="line">            &lt;p&gt;key:&#123;&#123; key &#125;&#125; val:&#123;&#123; val &#125;&#125;&lt;&#x2F;p&gt;</span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure><p>以上开发和配置完成后浏览器访问 <a href="http://127.0.0.1:8000/get_user_info?number=1000" target="_blank" rel="noopener">http://127.0.0.1:8000/get_user_info?number=1000</a> 就可以看到数据库中的数据在页面的渲染</p><h3 id="5-后台管理的简单使用"><a href="#5-后台管理的简单使用" class="headerlink" title="5 后台管理的简单使用"></a>5 后台管理的简单使用</h3><p>终端执行命令创建超级管理员并登陆</p><figure class="highlight python"><figcaption><span>manage.py createsuperuser```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后在http://<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>:<span class="number">8000</span>/admin中登陆进入后台管理界面</span><br><span class="line"></span><br><span class="line">例如需要在后台管理我们创建的family_app.user表，做一些常规的增删改查。</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 5.1 创建一个新的工程</span></span><br><span class="line"></span><br><span class="line">`python manage.py startapp family_user_admin`</span><br><span class="line"></span><br><span class="line"> 并将该工程注册到 family/settings.py的INSTALLED_APPS列表中</span><br><span class="line"></span><br><span class="line"><span class="comment">#### 5.2 开发models模块</span></span><br><span class="line"></span><br><span class="line">将我们的family_app.user表结构中需要我们修改的字段映射到发model中</span><br></pre></td></tr></table></figure><pre><code>check_status = (    (0, &apos;不生效&apos;),    (1, &apos;生效&apos;),)class MyUser(models.Model):    id = models.BigIntegerField(verbose_name=&apos;id&apos;, editable=False, primary_key=True, unique=True)    number = models.BigIntegerField(verbose_name=&apos;用户number&apos;, editable=True)    name = models.CharField(verbose_name=&apos;用户名&apos;, max_length=1024, blank=True)    mobile = models.CharField(verbose_name=&apos;电话&apos;, max_length=1024, blank=True)    status = models.IntegerField(verbose_name=&apos;用户状态&apos;, choices=check_status)    class Meta:        db_table = &apos;user&apos;</code></pre><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">#### 5.3 开发admin模块</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">将我们model中的需要展示和修改的字段添加到管理界面中</span><br></pre></td></tr></table></figure><pre><code>from models import MyUserclass MyUserAdmin(admin.ModelAdmin):    list_display = (&apos;number&apos;, &apos;name&apos;, &apos;mobile&apos;, &apos;status&apos;)    search_fields = (&apos;number&apos;, &apos;name&apos;, &apos;mobile&apos;)    def has_delete_permission(self, request, obj=None):        return Falseadmin.site.register(MyUser, MyUserAdmin)</code></pre><p>```</p><p>操作完以上步骤后在admin界面中可以看到我们的新增的管理模块MyUsers，点击进去就可以看到配置的信息，可以做增删改查操作</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;django是一个python语言开发的web框架。&lt;br&gt;主要的组件以及特点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;强大的数据库功能&lt;/li&gt;
&lt;li&gt;自带后台管理功能&lt;/li&gt;
&lt;li&gt;优雅的网址&lt;/li&gt;
&lt;li&gt;模板系统&lt;/li&gt;
&lt;li&gt;缓存系统&lt;/li&gt;
&lt;li&gt;国际化&lt;/
      
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="django" scheme="http://yoursite.com/tags/django/"/>
    
  </entry>
  
</feed>
